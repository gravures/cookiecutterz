"""
This type stub file was generated by pyright.
"""

from typing import Any, Callable, Collection, Iterable, Mapping, TYPE_CHECKING, TypeVar
from pdm.models.candidates import Candidate
from pdm.models.requirements import Requirement
from pdm.models.specifiers import PySpecSet
from pdm._types import CandidateInfo, FileHash, RepositoryConfig, SearchResult
from pdm.environments import BaseEnvironment

if TYPE_CHECKING:
    CandidateKey = tuple[str, str | None, str | None, bool]
T = TypeVar("T", bound="BaseRepository")
def cache_result(func: Callable[[T, Candidate], CandidateInfo]) -> Callable[[T, Candidate], CandidateInfo]:
    ...

class BaseRepository:
    """A Repository acts as the source of packages and metadata."""
    def __init__(self, sources: list[RepositoryConfig], environment: BaseEnvironment, ignore_compatibility: bool = ...) -> None:
        """
        :param sources: a list of sources to download packages from.
        :param environment: the bound environment instance.
        :param ignore_compatibility: if True, don't evaluate candidate against
            the current environment.
        """
        ...

    def get_filtered_sources(self, req: Requirement) -> list[RepositoryConfig]:
        """Get matching sources based on the index attribute."""
        ...

    def get_dependencies(self, candidate: Candidate) -> tuple[list[Requirement], PySpecSet, str]:
        """Get (dependencies, python_specifier, summary) of the candidate."""
        ...

    def is_this_package(self, requirement: Requirement) -> bool:
        """Whether the requirement is the same as this package"""
        ...

    def make_this_candidate(self, requirement: Requirement) -> Candidate:
        """Make a candidate for this package.
        In this case the finder will look for a candidate from the package sources
        """
        ...

    def find_candidates(self, requirement: Requirement, allow_prereleases: bool | None = ..., ignore_requires_python: bool = ..., minimal_version: bool = ...) -> Iterable[Candidate]:
        """Find candidates of the given NamedRequirement. Let it to be implemented in
        subclasses.

        :param requirement: the requirement to find
        :param allow_prereleases: whether to include pre-releases
        :param ignore_requires_python: whether to ignore the requires-python marker
        :param minimal_version: whether to prefer the minimal versions of the package
        """
        ...

    def get_hashes(self, candidate: Candidate) -> list[FileHash]:
        """Get hashes of all possible installable candidates
        of a given package version.
        """
        ...

    def dependency_generators(self) -> Iterable[Callable[[Candidate], CandidateInfo]]:
        """Return an iterable of getter functions to get dependencies, which will be
        called one by one.
        """
        ...

    def search(self, query: str) -> SearchResult:
        """Search package by name or summary.

        :param query: query string
        :returns: search result, a dictionary of name: package metadata
        """
        ...



class PyPIRepository(BaseRepository):
    """Get package and metadata from PyPI source."""
    DEFAULT_INDEX_URL = ...
    def dependency_generators(self) -> Iterable[Callable[[Candidate], CandidateInfo]]:
        ...

    def search(self, query: str) -> SearchResult:
        ...



class LockedRepository(BaseRepository):
    def __init__(self, lockfile: Mapping[str, Any], sources: list[RepositoryConfig], environment: BaseEnvironment) -> None:
        ...

    @property
    def all_candidates(self) -> dict[str, Candidate]:
        ...

    def dependency_generators(self) -> Iterable[Callable[[Candidate], CandidateInfo]]:
        ...

    def find_candidates(self, requirement: Requirement, allow_prereleases: bool | None = ..., ignore_requires_python: bool = ..., minimal_version: bool = ...) -> Iterable[Candidate]:
        ...

    def get_hashes(self, candidate: Candidate) -> list[FileHash]:
        ...

    def evaluate_candidates(self, groups: Collection[str]) -> Iterable[Candidate]:
        ...
