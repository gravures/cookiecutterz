"""
This type stub file was generated by pyright.
"""

import dataclasses
import os
from functools import cached_property
from pathlib import Path
from typing import Any, TYPE_CHECKING, no_type_check
from pdm.compat import importlib_metadata as im
from pdm.models.reporter import BaseReporter
from pdm.models.requirements import Requirement
from unearth import Link, Package
from pdm.environments import BaseEnvironment

if TYPE_CHECKING:
    ...
class MetadataDistribution(im.Distribution):
    """A wrapper around a single METADATA file to provide the Distribution interface"""
    def __init__(self, text: str) -> None:
        ...

    def locate_file(self, path: str | os.PathLike[str]) -> os.PathLike[str]:
        ...

    def read_text(self, filename: str) -> str | None:
        ...



class Candidate:
    """A concrete candidate that can be downloaded and installed.
    A candidate comes from the PyPI index of a package, or from the requirement itself
    (for file or VCS requirements). Each candidate has a name, version and several
    dependencies together with package metadata.
    """
    __slots__ = ...
    def __init__(self, req: Requirement, name: str | None = ..., version: str | None = ..., link: Link | None = ...) -> None:
        """
        :param req: the requirement that produces this candidate.
        :param name: the name of the candidate.
        :param version: the version of the candidate.
        :param link: the file link of the candidate.
        """
        ...

    def identify(self) -> str:
        ...

    def copy_with(self, requirement: Requirement) -> Candidate:
        ...

    @property
    def dep_key(self) -> tuple[str, str | None]:
        """Key for retrieving and storing dependencies from the provider.

        Return a tuple of (name, version). For URL candidates, the version is None but
        there will be only one for the same name so it is also unique.
        """
        ...

    @property
    def prepared(self) -> PreparedCandidate | None:
        ...

    def __eq__(self, other: Any) -> bool:
        ...

    def get_revision(self) -> str:
        ...

    def __repr__(self) -> str:
        ...

    def __str__(self) -> str:
        ...

    @classmethod
    def from_installation_candidate(cls, candidate: Package, req: Requirement) -> Candidate:
        """Build a candidate from unearth's find result."""
        ...

    @property
    def requires_python(self) -> str:
        """The Python version constraint of the candidate."""
        ...

    @requires_python.setter
    def requires_python(self, value: str) -> None:
        ...

    @no_type_check
    def as_lockfile_entry(self, project_root: Path) -> dict[str, Any]:
        """Build a lockfile entry dictionary for the candidate."""
        ...

    def format(self) -> str:
        """Format for output."""
        ...

    def prepare(self, environment: BaseEnvironment, reporter: BaseReporter | None = ...) -> PreparedCandidate:
        """Prepare the candidate for installation."""
        ...



@dataclasses.dataclass
class PreparedCandidate:
    """A candidate that has been prepared for installation.
    The metadata and built wheel are available.
    """
    candidate: Candidate
    environment: BaseEnvironment
    reporter: BaseReporter = ...
    def __post_init__(self) -> None:
        ...

    @cached_property
    def revision(self) -> str:
        ...

    def direct_url(self) -> dict[str, Any] | None:
        """PEP 610 direct_url.json data"""
        ...

    def build(self) -> Path:
        """Call PEP 517 build hook to build the candidate into a wheel"""
        ...

    def prepare_metadata(self, force_build: bool = ...) -> im.Distribution:
        ...

    @property
    def metadata(self) -> im.Distribution:
        ...

    def get_dependencies_from_metadata(self) -> list[str]:
        """Get the dependencies of a candidate from metadata."""
        ...

    def should_cache(self) -> bool:
        """Determine whether to cache the dependencies and built wheel."""
        ...
