"""
This type stub file was generated by pyright.
"""

import contextlib
import functools
from datetime import datetime
from pathlib import Path
from typing import Any, IO, Iterator, Mapping, TYPE_CHECKING
from packaging.version import Version
from pdm.compat import Distribution
from pdm._types import FileHash, RepositoryConfig

"""
Utility functions
"""
if TYPE_CHECKING:
    ...
_egg_fragment_re = ...
_packaging_version = ...
@functools.lru_cache(maxsize=1024)
def parse_version(version: str) -> Version:
    ...

PACKAGING_22 = ...
def create_tracked_tempdir(suffix: str | None = ..., prefix: str | None = ..., dir: str | None = ...) -> str:
    ...

def get_trusted_hosts(sources: list[RepositoryConfig]) -> list[str]:
    """Parse the project sources and return the trusted hosts"""
    ...

def url_without_fragments(url: str) -> str:
    ...

def join_list_with(items: list[Any], sep: Any) -> list[Any]:
    ...

def find_project_root(cwd: str = ...) -> str | None:
    """Recursively find a `pyproject.toml` at given path or current working directory."""
    ...

def convert_hashes(files: list[FileHash]) -> dict[str, list[str]]:
    """Convert Pipfile.lock hash lines into InstallRequirement option format.

    The option format uses a str-list mapping. Keys are hash algorithms, and
    the list contains all values of that algorithm.
    """
    ...

def get_user_email_from_git() -> tuple[str, str]:
    """Get username and email from git config.
    Return empty if not configured or git is not found.
    """
    ...

def add_ssh_scheme_to_git_uri(uri: str) -> str:
    """Cleans VCS uris from pip format"""
    ...

@contextlib.contextmanager
def atomic_open_for_write(filename: str | Path, *, mode: str = ..., encoding: str = ...) -> Iterator[IO]:
    ...

@contextlib.contextmanager
def cd(path: str | Path) -> Iterator:
    ...

def url_to_path(url: str) -> str:
    """
    Convert a file: URL to a path.
    """
    ...

def path_to_url(path: str) -> str:
    """
    Convert a path to a file: URL.  The path will be made absolute and have
    quoted path parts.
    """
    ...

def expand_env_vars(credential: str, quote: bool = ..., env: Mapping[str, str] | None = ...) -> str:
    """A safe implementation of env var substitution.
    It only supports the following forms:

        ${ENV_VAR}

    Neither $ENV_VAR and %ENV_VAR is supported.
    """
    ...

def expand_env_vars_in_auth(url: str) -> str:
    """In-place expand the auth in url"""
    ...

@functools.lru_cache
def path_replace(pattern: str, replace_with: str, dest: str) -> str:
    """Safely replace the pattern in a path with given string.

    :param pattern: the pattern to match
    :param replace_with: the string to replace with
    :param dest: the path to replace
    :return the replaced path
    """
    ...

def is_path_relative_to(path: str | Path, other: str | Path) -> bool:
    ...

def get_venv_like_prefix(interpreter: str | Path) -> tuple[Path | None, bool]:
    """Check if the given interpreter path is from a virtualenv,
    and return two values: the root path and whether it's a conda env.
    """
    ...

def find_python_in_path(path: str | Path) -> Path | None:
    """Find a python interpreter from the given path, the input argument could be:

    - A valid path to the interpreter
    - A Python root directory that contains the interpreter
    """
    ...

def get_rev_from_url(url: str) -> str:
    """Get the rev part from the VCS URL."""
    ...

@functools.lru_cache
def normalize_name(name: str, lowercase: bool = ...) -> str:
    ...

def comparable_version(version: str) -> Version:
    """Normalize a version to make it valid in a specifier."""
    ...

def is_egg_link(dist: Distribution) -> bool:
    """Check if the distribution is an egg-link install"""
    ...

def is_editable(dist: Distribution) -> bool:
    """Check if the distribution is installed in editable mode"""
    ...

def pdm_scheme(base: str) -> dict[str, str]:
    """Return a PEP 582 style install scheme"""
    ...

def is_url(url: str) -> bool:
    """Check if the given string is a URL"""
    ...

@functools.lru_cache
def fs_supports_link_method(method: str) -> bool:
    ...

def deprecation_warning(message: str, stacklevel: int = ..., raise_since: str | None = ...) -> None:
    """Show a deprecation warning with the given message and raise an error
    after a specified version.
    """
    ...

def is_pip_compatible_with_python(python_version: Version | str) -> bool:
    """Check the given python version is compatible with the pip installed"""
    ...

def path_without_fragments(path: str) -> Path:
    """Remove egg fragment from path"""
    ...

def is_in_zipapp() -> bool:
    """Check if the current process is running in a zipapp"""
    ...

@functools.lru_cache(None)
def package_installed(package_name: str) -> bool:
    ...

def validate_project_name(name: str) -> bool:
    """Check if the project name is valid or not"""
    ...

def sanitize_project_name(name: str) -> str:
    """Sanitize the project name and remove all illegal characters"""
    ...

def is_conda_base() -> bool:
    ...

def is_conda_base_python(python: Path) -> bool:
    ...

def filtered_sources(sources: list[RepositoryConfig], package: str | None) -> list[RepositoryConfig]:
    """Get matching sources based on the index attribute."""
    ...

def get_file_hash(filename: str | Path, algorithm: str = ...) -> str:
    """Calculate the hash of a file with the given algorithm"""
    ...

def convert_to_datetime(value: str) -> datetime:
    ...
