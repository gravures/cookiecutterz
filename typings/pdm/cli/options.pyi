"""
This type stub file was generated by pyright.
"""

import argparse
from typing import Any, Protocol, Sequence, TYPE_CHECKING
from pdm.project import Project

if TYPE_CHECKING:
    class ActionCallback(Protocol):
        def __call__(self, project: Project, namespace: argparse.Namespace, values: Any, option_string: str | None = ...) -> None:
            ...



class Option:
    """A reusable option object which delegates all arguments
    to parser.add_argument().
    """
    def __init__(self, *args: Any, **kwargs: Any) -> None:
        ...

    def add_to_parser(self, parser: argparse._ActionsContainer) -> None:
        ...

    def add_to_group(self, group: argparse._ArgumentGroup) -> None:
        ...

    def __call__(self, func: ActionCallback) -> Option:
        ...



class CallbackAction(argparse.Action):
    def __init__(self, *args: Any, callback: ActionCallback, **kwargs: Any) -> None:
        ...

    def __call__(self, parser: argparse.ArgumentParser, namespace: argparse.Namespace, values: Any, option_string: str | None = ...) -> None:
        ...



class ExtendMapAction(argparse._AppendAction):
    def __call__(self, parser: argparse.ArgumentParser, namespace: argparse.Namespace, values: str | Sequence[Any] | None, option_string: str | None = ...) -> None:
        ...



class ArgumentGroup(Option):
    """A reusable argument group object which can call `add_argument()`
    to add more arguments. And itself will be registered to the parser later.
    """
    def __init__(self, name: str, is_mutually_exclusive: bool = ..., required: bool = ...) -> None:
        ...

    def add_argument(self, *args: Any, **kwargs: Any) -> None:
        ...

    def add_to_parser(self, parser: argparse._ActionsContainer) -> None:
        ...

    def add_to_group(self, group: argparse._ArgumentGroup) -> None:
        ...



def split_lists(separator: str) -> type[argparse.Action]:
    """
    Works the same as `append` except each argument
    is considered a `separator`-separated list.
    """
    class SplitList(argparse.Action):
        ...



def from_splitted_env(name: str, separator: str) -> list[str] | None:
    """
    Parse a `separator`-separated list from a `name` environment variable if present.
    """
    ...

verbose_option = ...
no_cache_option = ...
dry_run_option = ...
lockfile_option = ...
@Option("--frozen-lockfile", "--no-lock", nargs=0, help="Don't try to create or update the lockfile. [env var: PDM_FROZEN_LOCKFILE]")
def frozen_lockfile_option(project: Project, namespace: argparse.Namespace, values: str | Sequence[Any] | None, option_string: str | None = ...) -> None:
    ...

@Option("--pep582", const="AUTO", metavar="SHELL", nargs="?", help="Print the command line to be eval'd by the shell")
def pep582_option(project: Project, namespace: argparse.Namespace, values: str | Sequence[Any] | None, option_string: str | None = ...) -> None:
    ...

install_group = ...
@Option("--no-isolation", dest="build_isolation", nargs=0, help="Disable isolation when building a source distribution that follows PEP 517, " "as in: build dependencies specified by PEP 518 must be already installed if this option is used.")
def no_isolation_option(project: Project, namespace: argparse.Namespace, values: str | Sequence[Any] | None, option_string: str | None = ...) -> None:
    ...

groups_group = ...
dev_group = ...
save_strategy_group = ...
skip_option = ...
update_strategy_group = ...
project_option = ...
global_option = ...
clean_group = ...
sync_group = ...
packages_group = ...
@Option("-I", "--ignore-python", nargs=0, help="Ignore the Python path saved in .pdm-python. [env var: PDM_IGNORE_SAVED_PYTHON]")
def ignore_python_option(project: Project, namespace: argparse.Namespace, values: str | Sequence[Any] | None, option_string: str | None = ...) -> None:
    ...

prerelease_option = ...
unconstrained_option = ...
venv_option = ...
lock_strategy_group = ...
config_setting_option = ...
