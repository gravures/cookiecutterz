"""
This type stub file was generated by pyright.
"""

from functools import cached_property
from pathlib import Path
from typing import Any, Callable, Iterable, Mapping, TYPE_CHECKING
from pdm._types import RepositoryConfig, Spinner
from pdm.models.backends import BuildBackend
from pdm.models.caches import CandidateInfoCache, HashCache, PackageCache, WheelCache
from pdm.models.python import PythonInfo
from pdm.models.repositories import BaseRepository, LockedRepository
from pdm.models.requirements import Requirement
from pdm.models.specifiers import PySpecSet
from pdm.project.config import Config
from pdm.project.lockfile import Lockfile
from pdm.project.project_file import PyProject
from resolvelib.reporters import BaseReporter
from pdm.core import Core
from pdm.environments import BaseEnvironment
from pdm.models.candidates import Candidate
from pdm.resolver.providers import BaseProvider

if TYPE_CHECKING:
    ...
PYENV_ROOT = ...
class Project:
    """Core project class.

    Args:
        core: The core instance.
        root_path: The root path of the project.
        is_global: Whether the project is global.
        global_config: The path to the global config file.
    """
    PYPROJECT_FILENAME = ...
    LOCKFILE_FILENAME = ...
    DEPENDENCIES_RE = ...
    def __init__(self, core: Core, root_path: str | Path | None, is_global: bool = ..., global_config: str | Path | None = ...) -> None:
        ...

    def __repr__(self) -> str:
        ...

    @cached_property
    def pyproject(self) -> PyProject:
        ...

    @property
    def lockfile(self) -> Lockfile:
        ...

    def set_lockfile(self, path: str | Path) -> None:
        ...

    @cached_property
    def config(self) -> Mapping[str, Any]:
        """A read-only dict configuration"""
        ...

    @property
    def scripts(self) -> dict[str, str | dict[str, str]]:
        ...

    @cached_property
    def project_config(self) -> Config:
        """Read-and-writable configuration dict for project settings"""
        ...

    @property
    def name(self) -> str:
        ...

    @property
    def python(self) -> PythonInfo:
        ...

    @python.setter
    def python(self, value: PythonInfo) -> None:
        ...

    def resolve_interpreter(self) -> PythonInfo:
        """Get the Python interpreter path."""
        ...

    def get_environment(self) -> BaseEnvironment:
        ...

    @property
    def environment(self) -> BaseEnvironment:
        ...

    @environment.setter
    def environment(self, value: BaseEnvironment) -> None:
        ...

    @property
    def python_requires(self) -> PySpecSet:
        ...

    def get_dependencies(self, group: str | None = ...) -> dict[str, Requirement]:
        ...

    def iter_groups(self) -> Iterable[str]:
        ...

    @property
    def all_dependencies(self) -> dict[str, dict[str, Requirement]]:
        ...

    @property
    def default_source(self) -> RepositoryConfig:
        """Get the default source from the pypi setting"""
        ...

    @property
    def sources(self) -> list[RepositoryConfig]:
        ...

    def get_repository(self, cls: type[BaseRepository] | None = ..., ignore_compatibility: bool = ...) -> BaseRepository:
        """Get the repository object"""
        ...

    @property
    def locked_repository(self) -> LockedRepository:
        ...

    def get_provider(self, strategy: str = ..., tracked_names: Iterable[str] | None = ..., for_install: bool = ..., ignore_compatibility: bool = ..., direct_minimal_versions: bool = ...) -> BaseProvider:
        """Build a provider class for resolver.

        :param strategy: the resolve strategy
        :param tracked_names: the names of packages that needs to update
        :param for_install: if the provider is for install
        :param ignore_compatibility: if the provider should ignore the compatibility when evaluating candidates
        :param direct_minimal_versions: if the provider should prefer minimal versions instead of latest
        :returns: The provider object
        """
        ...

    def get_reporter(self, requirements: list[Requirement], tracked_names: Iterable[str] | None = ..., spinner: Spinner | None = ...) -> BaseReporter:
        """Return the reporter object to construct a resolver.

        :param requirements: requirements to resolve
        :param tracked_names: the names of packages that needs to update
        :param spinner: optional spinner object
        :returns: a reporter
        """
        ...

    def get_lock_metadata(self) -> dict[str, Any]:
        ...

    def write_lockfile(self, toml_data: dict, show_message: bool = ..., write: bool = ..., **_kwds: Any) -> None:
        """Write the lock file to disk."""
        ...

    def make_self_candidate(self, editable: bool = ...) -> Candidate:
        ...

    def is_lockfile_hash_match(self) -> bool:
        ...

    def use_pyproject_dependencies(self, group: str, dev: bool = ...) -> tuple[list[str], Callable[[list[str]], None]]:
        """Get the dependencies array and setter in the pyproject.toml
        Return a tuple of two elements, the first is the dependencies array,
        and the second value is a callable to set the dependencies array back.
        """
        ...

    def add_dependencies(self, requirements: dict[str, Requirement], to_group: str = ..., dev: bool = ..., show_message: bool = ...) -> None:
        ...

    def init_global_project(self) -> None:
        ...

    @property
    def backend(self) -> BuildBackend:
        ...

    @property
    def cache_dir(self) -> Path:
        ...

    @cache_dir.setter
    def cache_dir(self, value: Path) -> None:
        ...

    def cache(self, name: str) -> Path:
        ...

    def make_wheel_cache(self) -> WheelCache:
        ...

    @property
    def package_cache(self) -> PackageCache:
        ...

    def make_candidate_info_cache(self) -> CandidateInfoCache:
        ...

    def make_hash_cache(self) -> HashCache:
        ...

    def iter_interpreters(self, python_spec: str | None = ..., search_venv: bool | None = ..., filter_func: Callable[[PythonInfo], bool] | None = ...) -> Iterable[PythonInfo]:
        """Iterate over all interpreters that matches the given specifier.
        And optionally install the interpreter if not found.
        """
        ...

    def find_interpreters(self, python_spec: str | None = ..., search_venv: bool | None = ...) -> Iterable[PythonInfo]:
        """Return an iterable of interpreter paths that matches the given specifier,
        which can be:
            1. a version specifier like 3.7
            2. an absolute path
            3. a short name like python3
            4. None that returns all possible interpreters
        """
        ...

    @property
    def is_distribution(self) -> bool:
        ...

    def get_setting(self, key: str) -> Any:
        """
        Get a setting from its dotted key (without the `tool.pdm` prefix).

        Returns `None` if the key does not exists.
        """
        ...

    def env_or_setting(self, var: str, key: str) -> Any:
        """
        Get a value from environment variable and fallback on a given setting.

        Returns `None` if both the environment variable and the key does not exists.
        """
        ...
