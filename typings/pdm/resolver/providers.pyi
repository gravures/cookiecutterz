"""
This type stub file was generated by pyright.
"""

from typing import Any, Callable, Iterable, Iterator, Mapping, Sequence, TYPE_CHECKING
from resolvelib import AbstractProvider
from resolvelib.resolvers import RequirementInformation
from pdm.models.candidates import Candidate
from pdm.models.repositories import BaseRepository
from pdm.models.requirements import Requirement
from pdm._types import Comparable

if TYPE_CHECKING:
    ...
_PROVIDER_REGISTORY: dict[str, type[BaseProvider]] = ...
def get_provider(strategy: str) -> type[BaseProvider]:
    ...

def provider_arguments(provider: type[BaseProvider]) -> set[str]:
    ...

def register_provider(strategy: str) -> Callable[[type[BaseProvider]], type[BaseProvider]]:
    ...

@register_provider("all")
class BaseProvider(AbstractProvider):
    def __init__(self, repository: BaseRepository, allow_prereleases: bool | None = ..., overrides: dict[str, str] | None = ..., direct_minimal_versions: bool = ..., locked_candidates: dict[str, Candidate] | None = ...) -> None:
        ...

    def requirement_preference(self, requirement: Requirement) -> Comparable:
        """Return the preference of a requirement to find candidates.

        - Editable requirements are preferered.
        - File links are preferred.
        - The one with narrower specifierset is preferred.
        """
        ...

    def identify(self, requirement_or_candidate: Requirement | Candidate) -> str:
        ...

    def get_preference(self, identifier: str, resolutions: dict[str, Candidate], candidates: dict[str, Iterator[Candidate]], information: dict[str, Iterator[RequirementInformation]], backtrack_causes: Sequence[RequirementInformation]) -> tuple[Comparable, ...]:
        ...

    def get_override_candidates(self, identifier: str) -> Iterable[Candidate]:
        ...

    def find_matches(self, identifier: str, requirements: Mapping[str, Iterator[Requirement]], incompatibilities: Mapping[str, Iterator[Candidate]]) -> Callable[[], Iterator[Candidate]]:
        ...

    def is_satisfied_by(self, requirement: Requirement, candidate: Candidate) -> bool:
        ...

    def get_dependencies(self, candidate: Candidate) -> list[Requirement]:
        ...



@register_provider("reuse")
class ReusePinProvider(BaseProvider):
    """A provider that reuses preferred pins if possible.

    This is used to implement "add", "remove", and "reuse upgrade",
    where already-pinned candidates in lockfile should be preferred.
    """
    def __init__(self, *args: Any, tracked_names: Iterable[str], **kwargs: Any) -> None:
        ...

    def get_reuse_candidate(self, identifier: str, requirement: Requirement | None) -> Candidate | None:
        ...

    def find_matches(self, identifier: str, requirements: Mapping[str, Iterator[Requirement]], incompatibilities: Mapping[str, Iterator[Candidate]]) -> Callable[[], Iterator[Candidate]]:
        ...



@register_provider("eager")
class EagerUpdateProvider(ReusePinProvider):
    """A specialized provider to handle an "eager" upgrade strategy.

    An eager upgrade tries to upgrade not only packages specified, but also
    their dependencies (recursively). This contrasts to the "only-if-needed"
    default, which only promises to upgrade the specified package, and
    prevents touching anything else if at all possible.

    The provider is implemented as to keep track of all dependencies of the
    specified packages to upgrade, and free their pins when it has a chance.
    """
    def get_reuse_candidate(self, identifier: str, requirement: Requirement | None) -> Candidate | None:
        ...

    def get_dependencies(self, candidate: Candidate) -> list[Requirement]:
        ...

    def get_preference(self, identifier: str, resolutions: dict[str, Candidate], candidates: dict[str, Iterator[Candidate]], information: dict[str, Iterator[RequirementInformation]], backtrack_causes: Sequence[RequirementInformation]) -> tuple[Comparable, ...]:
        ...



@register_provider("reuse-installed")
class ReuseInstalledProvider(ReusePinProvider):
    """A provider that reuses installed packages if possible."""
    def __init__(self, *args: Any, **kwargs: Any) -> None:
        ...

    def get_reuse_candidate(self, identifier: str, requirement: Requirement | None) -> Candidate | None:
        ...
